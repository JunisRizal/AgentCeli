#!/usr/bin/env python3
"""
AgentCeli - Free Data Collection Agent
Sammelt Kryptow√§hrungs-Daten nur mit kostenlosem Internet-Zugang
Keine AI-APIs erforderlich (Anthropic/OpenAI)
"""

import requests
import json
import time
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import pandas as pd
from pathlib import Path
import schedule

class AgentCeli:
    def __init__(self):
        """Initialisiert AgentCeli mit kostenlosen APIs"""
        
        # REAL LIVE API URLs - Echte Marktdaten
        self.coingecko_url = "https://api.coingecko.com/api/v3"
        self.binance_url = "https://api.binance.com/api/v3"
        self.coinbase_url = "https://api.exchange.coinbase.com"
        self.kraken_url = "https://api.kraken.com/0/public"
        self.fear_greed_url = "https://api.alternative.me/fng/"
        
        print("üî¥ LIVE MODE: Sammelt ECHTE Marktdaten von realen B√∂rsen")
        
        # Session f√ºr HTTP-Anfragen
        self.session = requests.Session()
        self.session.headers.update({
            'accept': 'application/json',
            'User-Agent': 'AgentCeli/1.0'
        })
        
        # Konservative Rate Limits f√ºr kostenlose APIs
        self.rate_limit_delay = 2.0  # 2 Sekunden zwischen Anfragen
        self.last_request_time = 0
        
        # REAL Kryptow√§hrungen mit B√∂rsen-Symbolen f√ºr LIVE Trading-Daten
        self.target_coins = [
            'bitcoin', 'ethereum', 'tether', 'bnb', 'solana',
            'xrp', 'usd-coin', 'cardano', 'dogecoin', 'avalanche-2'
        ]
        
        # REAL B√∂rsen-Symbole f√ºr Live-Preise
        self.trading_pairs = {
            'BTCUSDT': 'bitcoin',
            'ETHUSDT': 'ethereum', 
            'BNBUSDT': 'bnb',
            'SOLUSDT': 'solana',
            'XRPUSDT': 'xrp',
            'ADAUSDT': 'cardano',
            'DOGEUSDT': 'dogecoin'
        }
        
        # Daten-Speicher
        self.collected_data = {}
        self.last_update = None
        self.update_interval = 300  # 5 Minuten f√ºr kostenlose API
        self.is_running = False
        
        # Ausgabeordner
        self.output_dir = Path("agentceli_data")
        self.output_dir.mkdir(exist_ok=True)
        
        print("ü§ñ AgentCeli initialisiert - Nur kostenlose APIs, kein AI erforderlich")
    
    def respect_rate_limit(self):
        """Respektiert Rate Limits f√ºr kostenlose APIs"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.rate_limit_delay:
            sleep_time = self.rate_limit_delay - time_since_last
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()
    
    def safe_api_call(self, url: str, params: Dict = None) -> Optional[Dict]:
        """Sichere API-Anfrage mit Rate Limiting"""
        self.respect_rate_limit()
        
        try:
            response = self.session.get(url, params=params or {}, timeout=15)
            response.raise_for_status()
            return response.json()
            
        except requests.RequestException as e:
            print(f"‚ùå API Fehler: {e}")
            return None
    
    def get_basic_market_data(self) -> Optional[Dict]:
        """Holt Basis-Marktdaten von CoinGecko (kostenlos)"""
        coin_ids = ','.join(self.target_coins[:5])  # Limit f√ºr kostenlose API
        
        params = {
            'ids': coin_ids,
            'vs_currencies': 'usd,eur',
            'include_market_cap': 'true',
            'include_24hr_vol': 'true',
            'include_24hr_change': 'true',
            'include_last_updated_at': 'true'
        }
        
        url = f"{self.coingecko_url}/simple/price"
        data = self.safe_api_call(url, params)
        
        if data:
            print(f"‚úÖ Marktdaten f√ºr {len(data)} Coins abgerufen")
        
        return data
    
    def get_global_market_data(self) -> Optional[Dict]:
        """Holt globale Marktdaten (kostenlos)"""
        url = f"{self.coingecko_url}/global"
        data = self.safe_api_call(url)
        
        if data:
            print("‚úÖ Globale Marktdaten abgerufen")
        
        return data
    
    def get_trending_coins(self) -> Optional[Dict]:
        """Holt Trending Coins (kostenlos)"""
        url = f"{self.coingecko_url}/search/trending"
        data = self.safe_api_call(url)
        
        if data:
            print("‚úÖ Trending Coins abgerufen")
        
        return data
    
    def get_binance_live_prices(self) -> Optional[Dict]:
        """Holt ECHTE Live-Preise von Binance Exchange"""
        url = f"{self.binance_url}/ticker/24hr"
        data = self.safe_api_call(url)
        
        if data:
            # Filtere nur unsere Trading-Paare
            live_prices = {}
            for ticker in data:
                symbol = ticker.get('symbol')
                if symbol in self.trading_pairs:
                    live_prices[symbol] = {
                        'symbol': symbol,
                        'current_price': float(ticker.get('lastPrice', 0)),
                        'change_24h': float(ticker.get('priceChangePercent', 0)),
                        'volume_24h': float(ticker.get('volume', 0)),
                        'high_24h': float(ticker.get('highPrice', 0)),
                        'low_24h': float(ticker.get('lowPrice', 0)),
                        'trades_count': int(ticker.get('count', 0)),
                        'timestamp': int(ticker.get('closeTime', 0)),
                        'source': 'binance_live'
                    }
            
            print(f"üî¥ LIVE: {len(live_prices)} Binance Preise abgerufen")
            return live_prices
        
        return None
    
    def get_coinbase_live_prices(self) -> Optional[Dict]:
        """Holt ECHTE Live-Preise von Coinbase Pro"""
        live_prices = {}
        
        # Coinbase Pro verwendet andere Symbole
        coinbase_pairs = ['BTC-USD', 'ETH-USD', 'SOL-USD', 'XRP-USD', 'ADA-USD']
        
        for pair in coinbase_pairs:
            url = f"{self.coinbase_url}/products/{pair}/ticker"
            data = self.safe_api_call(url)
            
            if data:
                live_prices[pair] = {
                    'pair': pair,
                    'current_price': float(data.get('price', 0)),
                    'volume_24h': float(data.get('volume', 0)),
                    'best_bid': float(data.get('bid', 0)),
                    'best_ask': float(data.get('ask', 0)),
                    'timestamp': data.get('time'),
                    'source': 'coinbase_live'
                }
        
        if live_prices:
            print(f"üî¥ LIVE: {len(live_prices)} Coinbase Preise abgerufen")
        
        return live_prices
    
    def get_kraken_live_prices(self) -> Optional[Dict]:
        """Holt ECHTE Live-Preise von Kraken Exchange"""
        # Kraken Ticker f√ºr ausgew√§hlte Paare
        kraken_pairs = ['XBTUSD', 'ETHUSD', 'SOLUSD', 'XRPUSD', 'ADAUSD']
        pairs_param = ','.join(kraken_pairs)
        
        url = f"{self.kraken_url}/Ticker"
        params = {'pair': pairs_param}
        data = self.safe_api_call(url, params)
        
        if data and data.get('result'):
            live_prices = {}
            for pair, ticker_data in data['result'].items():
                live_prices[pair] = {
                    'pair': pair,
                    'current_price': float(ticker_data['c'][0]),  # Last trade price
                    'volume_24h': float(ticker_data['v'][1]),     # 24h volume
                    'high_24h': float(ticker_data['h'][1]),       # 24h high
                    'low_24h': float(ticker_data['l'][1]),        # 24h low
                    'trades_24h': int(ticker_data['t'][1]),       # 24h trades
                    'source': 'kraken_live'
                }
            
            print(f"üî¥ LIVE: {len(live_prices)} Kraken Preise abgerufen")
            return live_prices
        
        return None
    
    def get_fear_greed_index(self) -> Optional[Dict]:
        """Holt ECHTEN Fear & Greed Index (keine Simulation)"""
        try:
            response = requests.get(self.fear_greed_url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if data and 'data' in data:
                real_data = data['data'][0]
                print(f"üî¥ LIVE: Fear & Greed Index = {real_data.get('value')} ({real_data.get('value_classification')})")
                return real_data
                
        except requests.RequestException as e:
            print(f"‚ùå Fear & Greed Index Fehler: {e}")
        
        return None
    
    def get_market_dominance(self) -> Optional[Dict]:
        """Berechnet Markt-Dominanz aus verf√ºgbaren Daten"""
        url = f"{self.coingecko_url}/coins/markets"
        params = {
            'vs_currency': 'usd',
            'order': 'market_cap_desc',
            'per_page': 10,  # Top 10 f√ºr kostenlose API
            'page': 1,
            'sparkline': 'false'
        }
        
        data = self.safe_api_call(url, params)
        
        if data:
            print("‚úÖ Market Dominance Daten abgerufen")
        
        return data
    
    def calculate_market_metrics(self, basic_data: Dict, global_data: Dict, dominance_data: List) -> Dict:
        """Berechnet Marktmetriken aus kostenlosen Daten"""
        metrics = {
            'total_market_cap_usd': 0,
            'total_volume_24h_usd': 0,
            'average_24h_change': 0,
            'coins_above_zero': 0,
            'coins_below_zero': 0,
            'market_dominance': {},
            'global_metrics': {},
            'top_performers': [],
            'top_losers': []
        }
        
        # Globale Metriken
        if global_data and 'data' in global_data:
            global_info = global_data['data']
            metrics['global_metrics'] = {
                'total_market_cap_usd': global_info.get('total_market_cap', {}).get('usd'),
                'total_volume_24h_usd': global_info.get('total_volume', {}).get('usd'),
                'market_cap_percentage': global_info.get('market_cap_percentage', {}),
                'active_cryptocurrencies': global_info.get('active_cryptocurrencies'),
                'markets': global_info.get('markets'),
                'market_cap_change_24h_percentage': global_info.get('market_cap_change_percentage_24h_usd')
            }
        
        # Basis-Daten verarbeiten
        changes = []
        for coin_id, data in basic_data.items():
            if data.get('usd_market_cap'):
                metrics['total_market_cap_usd'] += data['usd_market_cap']
            if data.get('usd_24h_vol'):
                metrics['total_volume_24h_usd'] += data['usd_24h_vol']
            
            change = data.get('usd_24h_change')
            if change is not None:
                changes.append((coin_id, change))
                if change > 0:
                    metrics['coins_above_zero'] += 1
                else:
                    metrics['coins_below_zero'] += 1
        
        if changes:
            metrics['average_24h_change'] = sum(change for _, change in changes) / len(changes)
            changes.sort(key=lambda x: x[1], reverse=True)
            metrics['top_performers'] = changes[:3]
            metrics['top_losers'] = changes[-3:]
        
        # Market Dominance
        if dominance_data:
            total_cap = sum(coin.get('market_cap', 0) for coin in dominance_data)
            for coin in dominance_data:
                name = coin.get('name', coin.get('id', 'unknown'))
                cap = coin.get('market_cap', 0)
                if total_cap > 0:
                    metrics['market_dominance'][name] = round((cap / total_cap) * 100, 2)
        
        return metrics
    
    def collect_all_data(self):
        """Sammelt ECHTE Live-Marktdaten von realen B√∂rsen"""
        print(f"üî¥ LIVE DATA COLLECTION um {datetime.now().strftime('%H:%M:%S')}")
        print("üìç Sammelt ECHTE Daten von: Binance, Coinbase, Kraken, CoinGecko")
        
        # REAL Basis-Marktdaten von CoinGecko
        basic_data = self.get_basic_market_data()
        if not basic_data:
            print("‚ùå CoinGecko Basis-Daten konnten nicht abgerufen werden")
            return
        
        # REAL B√∂rsen-Daten
        binance_live = self.get_binance_live_prices()
        coinbase_live = self.get_coinbase_live_prices() 
        kraken_live = self.get_kraken_live_prices()
        
        # REAL Marktdaten
        global_data = self.get_global_market_data()
        trending_data = self.get_trending_coins()
        fear_greed = self.get_fear_greed_index()
        dominance_data = self.get_market_dominance()
        
        # Metriken berechnen
        market_metrics = self.calculate_market_metrics(basic_data, global_data, dominance_data or [])
        
        # REAL LIVE Daten kombinieren - KEINE Simulation!
        self.collected_data = {
            'timestamp': datetime.now().isoformat(),
            'data_type': 'LIVE_REAL_MARKET_DATA',
            'agent_info': {
                'name': 'AgentCeli',
                'version': '2.0_LIVE',
                'mode': 'REAL_DATA_ONLY',
                'ai_apis': 'NONE',
                'simulation': False,
                'live_trading_data': True
            },
            'update_interval_seconds': self.update_interval,
            'data_sources': {
                'binance': 'LIVE_EXCHANGE_API',
                'coinbase': 'LIVE_EXCHANGE_API', 
                'kraken': 'LIVE_EXCHANGE_API',
                'coingecko': 'REAL_MARKET_API',
                'fear_greed': 'LIVE_SENTIMENT_API'
            },
            'live_exchange_data': {
                'binance': binance_live or {},
                'coinbase': coinbase_live or {},
                'kraken': kraken_live or {}
            },
            'coins': self.process_coin_data(basic_data),
            'market_metrics': market_metrics,
            'trending_coins': trending_data,
            'fear_greed_index': fear_greed,
            'market_dominance': dominance_data,
            'collection_stats': {
                'total_coins_collected': len(basic_data) if basic_data else 0,
                'live_exchange_sources': len([x for x in [binance_live, coinbase_live, kraken_live] if x]),
                'real_apis_used': 3 + (1 if trending_data else 0) + (1 if fear_greed else 0),
                'collection_timestamp': datetime.now().isoformat(),
                'data_authenticity': 'VERIFIED_LIVE'
            }
        }
        
        self.last_update = datetime.now()
        self.save_collected_data()
        
        print(f"üî¥ LIVE DATA gesammelt: {len(self.collected_data['coins'])} Coins")
        print(f"üìä ECHTE B√∂rsen verbunden: {self.collected_data['collection_stats']['live_exchange_sources']}")
        print(f"‚úÖ AUTHENTIZIT√ÑT: {self.collected_data['collection_stats']['data_authenticity']}")
        
        # Zeige Live-Preise als Beweis
        if binance_live:
            btc_price = next((v['current_price'] for k, v in binance_live.items() if 'BTC' in k), None)
            if btc_price:
                print(f"üî¥ LIVE BTC Preis von Binance: ${btc_price:,.2f}")
        
        if coinbase_live and 'BTC-USD' in coinbase_live:
            print(f"üî¥ LIVE BTC Preis von Coinbase: ${coinbase_live['BTC-USD']['current_price']:,.2f}")
    
    def process_coin_data(self, basic_data: Dict) -> Dict:
        """Verarbeitet Coin-Daten ohne AI"""
        processed = {}
        
        for coin_id, data in basic_data.items():
            processed[coin_id] = {
                'id': coin_id,
                'price_usd': data.get('usd'),
                'price_eur': data.get('eur'),
                'market_cap_usd': data.get('usd_market_cap'),
                'volume_24h_usd': data.get('usd_24h_vol'),
                'change_24h_percent': data.get('usd_24h_change'),
                'last_updated': data.get('last_updated_at'),
                'status': 'up' if data.get('usd_24h_change', 0) > 0 else 'down'
            }
        
        return processed
    
    def save_collected_data(self):
        """Speichert gesammelte Daten"""
        if not self.collected_data:
            return
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Aktuelle Daten
        current_file = self.output_dir / "agentceli_current.json"
        
        # CSV Export
        csv_file = self.output_dir / f"agentceli_data_{timestamp}.csv"
        
        try:
            # JSON speichern
            with open(current_file, 'w', encoding='utf-8') as f:
                json.dump(self.collected_data, f, indent=2, ensure_ascii=False)
            
            # CSV Export f√ºr einfache Analyse
            if self.collected_data.get('coins'):
                df = pd.DataFrame.from_dict(self.collected_data['coins'], orient='index')
                df.to_csv(csv_file)
                print(f"üìÑ CSV exportiert: {csv_file}")
            
            # Archivierung alle Stunde
            if datetime.now().minute == 0:
                archive_file = self.output_dir / f"agentceli_archive_{timestamp}.json"
                with open(archive_file, 'w', encoding='utf-8') as f:
                    json.dump(self.collected_data, f, indent=2, ensure_ascii=False)
                print(f"üìÅ Daten archiviert: {archive_file}")
                
        except Exception as e:
            print(f"‚ùå Fehler beim Speichern: {e}")
    
    def start_data_collection(self):
        """Startet kontinuierliche Datensammlung"""
        if self.is_running:
            print("‚ö†Ô∏è AgentCeli l√§uft bereits")
            return
        
        self.is_running = True
        print(f"üöÄ AgentCeli gestartet (Update alle {self.update_interval}s)")
        print(f"üìä √úberwachte Coins: {len(self.target_coins)}")
        print(f"üåê Nur kostenlose APIs - Kein AI erforderlich")
        
        # Erste Datensammlung
        self.collect_all_data()
        
        # Schedule f√ºr regelm√§√üige Updates
        schedule.every(self.update_interval).seconds.do(self.collect_all_data)
        
        def run_scheduler():
            while self.is_running:
                schedule.run_pending()
                time.sleep(1)
        
        scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
        scheduler_thread.start()
        
        print("‚úÖ AgentCeli aktiv - Sammelt Daten ohne AI-APIs")
    
    def stop_data_collection(self):
        """Stoppt die Datensammlung"""
        self.is_running = False
        print("‚èπÔ∏è AgentCeli gestoppt")
    
    def get_summary(self) -> Dict:
        """Gibt eine Zusammenfassung der gesammelten Daten zur√ºck"""
        if not self.collected_data:
            return {"status": "no_data", "message": "Keine Daten gesammelt"}
        
        summary = {
            'agent_status': 'active' if self.is_running else 'stopped',
            'last_update': self.last_update.isoformat() if self.last_update else None,
            'coins_tracked': len(self.collected_data.get('coins', {})),
            'data_sources': len(self.collected_data.get('data_sources', {})),
            'ai_apis_used': 0,  # AgentCeli verwendet keine AI-APIs
            'internet_only': True,
            'top_performers': self.collected_data.get('market_metrics', {}).get('top_performers', []),
            'market_summary': {
                'total_market_cap': self.collected_data.get('market_metrics', {}).get('global_metrics', {}).get('total_market_cap_usd'),
                'coins_up': self.collected_data.get('market_metrics', {}).get('coins_above_zero', 0),
                'coins_down': self.collected_data.get('market_metrics', {}).get('coins_below_zero', 0)
            }
        }
        
        return summary

def main():
    """Hauptfunktion f√ºr AgentCeli - LIVE REAL DATA MODE"""
    print("üî¥ AgentCeli - LIVE REAL MARKET DATA COLLECTOR")
    print("=" * 60)
    print("‚úÖ KEINE AI-APIs (Anthropic/OpenAI)")
    print("üåê Nur Internet-Zugang f√ºr ECHTE B√∂rsen-APIs")
    print("üìä SAMMELT LIVE DATEN VON:")
    print("   ‚Ä¢ Binance Exchange (LIVE)")
    print("   ‚Ä¢ Coinbase Pro (LIVE)")  
    print("   ‚Ä¢ Kraken Exchange (LIVE)")
    print("   ‚Ä¢ CoinGecko Market Data (REAL)")
    print("   ‚Ä¢ Fear & Greed Index (REAL)")
    print("‚ùå KEINE Simulation - NUR ECHTE Marktdaten!")
    print()
    
    # AgentCeli erstellen
    agent = AgentCeli()
    
    # Check if running in background (no stdin available)
    import sys
    if not sys.stdin.isatty():
        # Running in background - automatically start continuous data collection
        print("üöÄ Automatischer Start (Hintergrund-Modus)")
        choice = "1"
    else:
        # Interactive mode
        print("üìã Verf√ºgbare Optionen:")
        print("1. Datensammlung starten (kontinuierlich)")
        print("2. Einmalige Datensammlung")
        print("3. Status und Zusammenfassung anzeigen")
        
        choice = input("\nW√§hlen Sie eine Option (1-3): ").strip()
    
    if choice == "1":
        agent.start_data_collection()
        print("\nüí° Dr√ºcken Sie Ctrl+C zum Beenden")
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            agent.stop_data_collection()
            print("\nüëã AgentCeli beendet")
            
    elif choice == "2":
        agent.collect_all_data()
        if agent.collected_data:
            summary = agent.get_summary()
            print(f"\nüî¥ LIVE DATA SAMMLUNG ABGESCHLOSSEN:")
            print(f"üí∞ ECHTE Coins gesammelt: {summary['coins_tracked']}")
            print(f"üìà Coins gestiegen: {summary['market_summary']['coins_up']}")
            print(f"üìâ Coins gefallen: {summary['market_summary']['coins_down']}")
            print(f"üè¶ LIVE B√∂rsen verbunden: {agent.collected_data['collection_stats']['live_exchange_sources']}")
            print(f"üåê Nur Internet + B√∂rsen-APIs: {summary['internet_only']}")
            print(f"ü§ñ AI-APIs verwendet: {summary['ai_apis_used']} (KEINE!)")
            print(f"‚úÖ Daten-Authentizit√§t: {agent.collected_data['collection_stats']['data_authenticity']}")
            
            # Zeige Live-Preise als Beweis f√ºr echte Daten
            live_exchanges = agent.collected_data.get('live_exchange_data', {})
            print(f"\nüî¥ BEWEIS - LIVE PREISE JETZT:")
            for exchange, data in live_exchanges.items():
                if data:
                    print(f"  üìä {exchange.upper()}: {len(data)} Live-Preise gesammelt")
            
    elif choice == "3":
        if agent.collected_data:
            summary = agent.get_summary()
            print(json.dumps(summary, indent=2, ensure_ascii=False))
        else:
            print("‚ö†Ô∏è Keine Daten verf√ºgbar. Starten Sie zuerst die Datensammlung.")
    
    else:
        print("‚ùå Ung√ºltige Auswahl")

if __name__ == "__main__":
    main()